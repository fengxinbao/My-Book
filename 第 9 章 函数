第 9 章 函数

9.3 形式参数（paramet） 与 实际参数（argument）

形式参数出现在函数定义中，它们以假名字来表示函数调用时需要提供的值。
实际参数是出现在函数调用中的表达式。

在 C 语言中，实际参数是通过值传递的：调用函数时，计算出每个实际参数的值并且把它赋值给相应的形式参数。在函数执行过程中，对形式参数的改变不会影响实际参数的值。

实际参数按值传递既有利也有弊。因为形式参数的修改不会影响到相应的实际参数，所以可以把形式参数作为函数内的变量来使用，这样可以减少真正需要的变量的数量。

程序：计算 x 的 n 次幂

int power(int x, int n){
	int i, result = 1;
	
	for(i = 1; i <= n; i++){
		result = result * x;
	}
	
	return result;
}

由于 n 只是原始指数的副本，所以可以在函数体内修改它，因此就不需要变量 i 了：

int power(int x, int n){
	int result = 1;
	
	while (n-- > 0) {
		result = result * x;
	}
	
	return result;
}

但是，按值传递实参导致某些函数无法编写，例如，我们需要一个可以把 double 型值分解成整数部分和小数部分的函数，由于函数无法返回两个数（如果换成 Java，我们可以返回一个包含这两个值的对象），所以可以试着把两个变量传递给函数并且修改它们（实际上时修改不了的）：

void decompose(double x, long int_part, double frac_part) {
	int_part = (long) x;      // drops the fractional part of x
	frac_part = x - int_part;
}

假设采用下面的方法调用整个函数：

int i;
double d;
decompose(3.1415926, i, d);

函数执行结束后，i 和 d 的值与函数执行前是完全一样的，并未发生改变。



第 11 章 指针

2018年3月28日
16:23

11.1 指针变量

计算机将内存分割为字节（8 比特），每个字节都有唯一的地址。程序中每个变量占一个或多个字节内存，其第一个字节的地址称为变量的地址。

地址的取值范围可能不同于整数的取值范围，所以一定不能用普通整形变量存储地址，而要用特殊的指针变量存储地址。

指针就是地址。

指针变量的声明：

	int *p;  
	// p 是指向 int 类型对象的指针变量。C 语言要求每个指针变量只能指向一种特定类型的对象。


11.2 取址运算符和间接寻址运算符

	取址运算符    &  	如果 x 是变量，&x 就是 x 在内存中的地址，即 p。     
	间接寻址运算符：*	如果 p 是指针，*p 就是 p 当前指向的对象，即 x。     

	int i, *p;
	p = &i;
	printf("%d\n", *p);

	注意：给 *p 赋值尤其危险。


11.3 指针赋值

	int i, j, *p, *q;
	q = p;   // 把 p 的内容，即 i 的地址（&i）复制给 q，q 指向了 p 所指向的地方，p 和 q 都指向 i。
	*q = *p; // 把 p 指向的对象 i 的值复制到 q 指向的对象（变量 j）中。


11.4 指针作为参数

指针有什么益处呢？

在 9.3 节中我们看到，C 语言用值进行参数传递，所以在函数调用中用作实际参数的变量无法改变。指针提供了解决此类问题的方法：不再传递变量 x，而是传递 x 的指针，即 &x，或说 x 的地址，同时声明相应的形式参数 p 为指针（所以形参要写成 *p 而不是 p）。函数体内 *p 的每次出现都将是对 x 的间接引用：

	void decompose(double x, long *int_part, double *frac_part) {
		*int_part = (long) x;      // drops the fractional part of x
		*frac_part = x - *int_part;
	}

以如下方式调用 decompose 函数：

	int i;
	double d;
	decompose(3.1415926, &i, &d);

这时，decompose 函数的实际参数是指向 i 和 d 的指针，而不是 i 和 d 的值。

注意：向函数传递需要的指针却失败了可能会产生严重的后果。例如，如果传入的是 i 和 d，而不是 &i 和 &d，函数会把 i 和 d 当成指针来用，函数会修改未知的内存地址，而不是 i 和 d 的内存地址。


使用 const 保护参数

当调用函数并且把指向变量的指针作为参数传入时，通常会假设函数将修改变量（否则为什么要传递指针呢？）。例如，看到语句

	f(&x);

大概是希望 f 改变 x 的值。但是，f 仅检查 x 的值而不是改变它也是可能的。可以使用单词 const 来表明函数不会改变指针参数所指向的对象：

	void f(const int *p) {
		*p = 0;  /*** WRONG ***/
	}

指针高效的原因是：如果变量需要大量的存储空间，那么传递变量的值会浪费时间和空间。



11.5 指针作为返回值

	int *max(int *a, int *b) {
		if(*a > *b)
			return a;
		else
			return b;
	}
	
	int *p, i, j;
	p = max(&i, &j);

函数调用结束后，p 或指向 i，或指向 j。


第 12 章 指针和数组

2018年4月13日
17:02

12.1 指针的算术运算

指针可以指向数组元素：

	int a[10], *p = &a[0];
	a = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

现在可以通过 *p 访问 a[0]：

	*p = 5;

C 语言支持 3 种指针运算：

	• 指针 + 整数：如果 p 指向 a[i]，p+j 指向 a[i+j]，前提是 a[i+j] 存在。
	• 指针 - 整数：如果 p 指向 a[i]，p-j 指向 a[i-j]，前提是 a[i-j] 存在。
	• 指针 - 指针：如果 p 指向 a[i]，q   指向 a[j],  p-q 指向 a[i-j]，前提是 a[i-j] 存在。
	

指针比较：下面的赋值发生后，p <= q 的值是 0，p >= q 的值是 1。

	p = &a[5];
	q = &a[1];

指向复合常量的指针：

	int *p = (int[]) {3, 0, 3, 5, 4};

p 因此指向一个五元数组的第一个元素，这相当于如下语句的简写：

	int a[] = {3, 0, 3, 5, 4};
	int *p = &a[0];



12.2 指针用于数组处理

