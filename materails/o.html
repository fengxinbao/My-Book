<h1 id="第-8-章-泛型程序设计">第 8 章 泛型程序设计</h1>
<blockquote>
<p>2018年5月23日</p>
</blockquote>
<h2 id="为什么使用泛型程序设计">8.1 为什么使用泛型程序设计</h2>
<p>使用泛型编写的代码可以被很多不同类型的对象所重用。</p>
<p>不使用泛型的代码存在两个问题：</p>
<ul>
<li>当获取一个值时必需进行强制类型转换。</li>
</ul>
<pre class="java,l1"><code>List files = new ArrayList();
// do something
String filename = (String) files.get(0);</code></pre>
<ul>
<li>没有错误检查。可以向 ArrayList 中添加任何类的对象。</li>
</ul>
<pre class="java,l1"><code>files.add(new File(&quot;...&quot;));</code></pre>
<p>泛型编程利用<strong>类型参数</strong>（type parameters）解决了以上两个问题，使程序编写更容易、程序更安全、可读性更高。</p>
<h2 id="定义简单泛型类">8.2 定义简单泛型类</h2>
<pre class="java,l1"><code>/**
 * 将类型变量 T 用尖括号括起来，放在类名的后面
 * @param &lt;T&gt;
 */
public class Pair&lt;T&gt; {

  private T first;
  private T second;

  public Pair() {
    first = null;
    second = null;
  }
  public Pair(T first, T second) {
    this.first = first;
    this.second = second;
  }
  public T getFirst() {
    return first;
  }
  public T getSecond() {
    return second;
  }
  public void setFirst(T newValue) {
    first = newValue;
  }
  public void setSecond(T newValue) {
    second = newValue;
  }
}</code></pre>
<p>用具体的类型替换类型变量叫做<strong>实例化泛型类型</strong>：</p>
<pre><code>Pair&lt;String&gt;</code></pre>
<h3 id="使用泛型类">使用泛型类</h3>
<pre class="java,l1"><code>public class ArrayAlg {

  public static void main(String[] args) {
    String[] words = { &quot;Mary&quot;, &quot;had&quot;, &quot;a&quot;, &quot;little&quot;, &quot;lamb&quot; };
    Pair&lt;String&gt; mm = ArrayAlg.minmax(words);
    System.out.println(&quot;min = &quot; + mm.getFirst());
    System.out.println(&quot;max = &quot; + mm.getSecond());
  }

  public static Pair&lt;String&gt; minmax(String[] a) {
    if (a == null || a.length == 0)
      return null;

    String min = a[0];
    String max = a[0];

    for (int i = 1; i &lt; a.length; i++) {
      if (min.compareTo(a[i]) &gt; 0){
    min = a[i];
      }
      if (max.compareTo(a[i]) &lt; 0){
    max = a[i];
      }
    }

    return new Pair&lt;&gt;(min, max);
  }
}</code></pre>
<h2 id="泛型方法">8.3 泛型方法</h2>
<p>泛型方法可以定义在泛型类中，也可以定义在普通类中。类型变量放在修饰符后面，返回类型前面。</p>
<pre class="java,l1"><code>public class ArrayAlg {

  public static &lt;T&gt; T getMiddle(T... a) {
    return a[a.length / 2];
  }
}</code></pre>
<p><strong>调用泛型方法：</strong></p>
<pre class="java,l1"><code>String middle = ArrayAlg.&lt;String&gt;getMiddle(&quot;John&quot;, &quot;Tommy&quot;, &quot;Q&quot;);</code></pre>
<p>可以省略 <code>&lt;String&gt;</code> 类型参数:</p>
<pre class="java,l1"><code>String middle = ArrayAlg.getMiddle(&quot;John&quot;, &quot;Tommy&quot;, &quot;Q&quot;);</code></pre>
<p>编译器会对下面的调用报错：Type safety: A generic array of Number&amp;Comparable&lt;?&gt; is created for a varargs parameter.</p>
<pre class="java,l1"><code>double middle = ArrayAlg.getMiddle(7.3, 3, 5);</code></pre>
<p>[原因] 编译器会自动将三个参数打包一个为一个 Double 类型和两个 Integer 类型，而后寻找这些类的共同超类型。事实上，会找到两个这样的超类型：Number 和 Comparable 接口。</p>
<p>[解决方法] 将所有的参数改为 double 值：</p>
<pre class="java,l1"><code>double middle = ArrayAlg.getMiddle(7.3, 3.0, 5.0);</code></pre>
<h2 id="类型变量的限定">8.4 类型变量的限定</h2>
<p>[提出问题] 假设我们希望计算数组中的最小元素，看下面定义的方法：</p>
<pre class="java,l1"><code>class ArrayAlg {
  public static &lt;T&gt; T min(T[] a) {
    if (a == null || a.length == 0)
      return null;
    T smallest = a[0];
    for (int i = 1; i &lt; a.length; i++) {
      if (smallest.compareTo(a[i]) &gt; 0)
    smallest = a[i];
    }
    return smallest;
  }
}</code></pre>
<p>上面的代码的问题在于，无法保证 T 具有 compareTo 方法，因为 T 可以是任何类型。解决方法是限定 T 为 Compareable 的子类：<code>&lt;T extends Comparable&lt;T&gt;&gt;</code></p>
<pre class="java,l1"><code>class ArrayAlg {
  public static &lt;T extends Comparable&lt;T&gt;&gt; T min(T[] a) {
    if (a == null || a.length == 0)
      return null;
    T smallest = a[0];
    for (int i = 1; i &lt; a.length; i++) {
      if (smallest.compareTo(a[i]) &gt; 0)
    smallest = a[i];
    }
    return smallest;
  }
}</code></pre>
<p>研究下面的程序，它计算一个泛型数组的最大值和最小值：</p>
<pre class="java,l1"><code>class ArrayAlg {
  public static &lt;T extends Comparable&lt;T&gt;&gt; Pair&lt;T&gt; minMax(T[] a) {
    if (a == null || a.length == 0)
      return null;
    T min = a[0];
    T max = a[0];
    for (int i = 0; i &lt; a.length; i++) {
      if (min.compareTo(a[i]) &gt; 0) {
    min = a[i];
      }
      if (max.compareTo(a[i]) &lt; 0) {
    max = a[i];
      }
    }
    return new Pair&lt;&gt;(min, max);
  }
}</code></pre>
<h3 id="多个限定">多个限定</h3>
<p>限定可以有多个，如：</p>
<pre><code>T extends Comparable &amp; Serializable</code></pre>
<p>多个限定中最多只能有一个类，多个接口，且类要放在限定列表中的第一个。</p>
<h2 id="泛型代码和虚拟机">8.5 泛型代码和虚拟机</h2>
<p>虚拟机没有泛型对象，所有对象都属于普通类。</p>
<h3 id="类型擦除">8.5.1 类型擦除</h3>
<p>类型擦除会将类型变量替换为限定类型，无限定的变量用 Object。</p>
<p>例如，<code>Pair&lt;T&gt;</code> 类型擦除后变为：</p>
<pre class="java,l1"><code>public class Pair {
  private Object first;
  private Object second;

  public Pair() {
    first = null;
    second = null;
  }

  public Pair(Object first, Object second) {
    this.first = first;
    this.second = second;
  }

  public Object getFirst() {
    return first;
  }

  public Object getSecond() {
    return second;
  }

  public void setFirst(Object newValue) {
    first = newValue;
  }

  public void setSecond(Object newValue) {
    second = newValue;
  }
}</code></pre>
